// مقداردهی متغیرهای کلیدی قبل از هر استفاده
const allFields = window.allFieldsData?.fields || [];
const allFormulas = window.allFormulasData?.formulas || [];
const products = window.productsData || [];

// استخراج همه گروه‌های کالا به صورت داینامیک
function getAllProductGroups() {
  const groups = new Set();
  
  // استخراج از فیلدها
  (window.allFieldsData?.fields || []).forEach(field => {
    if (field.group) {
      groups.add(field.group.toString().trim().toLowerCase());
    }
  });
  
  // استخراج از فرمول‌ها
  (window.allFormulasData?.formulas || []).forEach(formula => {
    if (formula.group) {
      groups.add(formula.group.toString().trim().toLowerCase());
    }
  });
  
  // اگر هیچ گروهی پیدا نشد، حداقل گروه‌های اصلی را برگردان
  if (groups.size === 0) {
    groups.add('melted');
    groups.add('manufactured');
    groups.add('coin');
    groups.add('jewelry');
    groups.add('goldbullion');
    groups.add('silverbullion');
  }
  
  console.log('All product groups from field/formula definitions:', Array.from(groups));
  return Array.from(groups);
}

document.addEventListener('DOMContentLoaded', async function () {
  if (window.jalaliDatepicker) jalaliDatepicker.startWatch();

  // تعریف baseUrl
  const baseUrl = window.baseUrl || ''; // اگر در HTML تعریف نشده باشد، خالی در نظر گرفته می‌شود
  console.log('Base URL:', baseUrl); // لاگ کردن مقدار baseUrl

  // فراخوانی loadAssayOffices در ابتدای اسکریپت
  loadAssayOffices();

  const itemsContainer = document.getElementById('transaction-items-container');
  const addItemButton = document.getElementById('add-transaction-item');
  const itemRowTemplateEl = document.getElementById('item-row-template');
  const transactionForm = document.getElementById('transaction-form');

  if (!itemsContainer || !addItemButton || !itemRowTemplateEl) {
    console.error('Transaction form critical elements missing. Aborting script.');
    return;
  }
  
  // --- رفع مشکل لود اقلام هنگام ویرایش ---
  const itemRowTemplate = itemRowTemplateEl.innerHTML;
  let itemIndex = 0;
  if (Array.isArray(window.transactionItemsData) && window.transactionItemsData.length > 0) {
    window.transactionItemsData.forEach(function(item) {
      renderItemRow(item, itemIndex);
      itemIndex++;
    });
  } else {
    renderItemRow(null, itemIndex);
    itemIndex++;
  }
  // --- پایان رفع مشکل ---
  
  // افزودن رویداد submit به فرم برای خالص‌سازی اعداد قبل از ارسال
  if (transactionForm) {
    transactionForm.addEventListener('submit', function(event) {
      event.preventDefault();
  
      const isValid = sanitizeAllNumericFields();
      if (!isValid) {
        showMessage('error', 'لطفاً خطاهای موجود در فرم را اصلاح کنید سپس دوباره تلاش کنید.');
        return;
      }
  
      // جمع‌آوری داده‌های فرم
      const formData = new FormData(transactionForm);
  
      // ارسال با fetch
      fetch(transactionForm.action, {
        method: 'POST',
        body: formData,
        headers: {
          'X-Requested-With': 'XMLHttpRequest'
        }
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          // موفقیت: ریدایرکت به لیست معاملات
          window.location.href = '/app/transactions';
        } else {
          // خطا: نمایش پیام خطا و عدم رفرش فرم
          if (data.errors && Array.isArray(data.errors)) {
            showMessage('error', data.errors.join('<br>'));
          } else if (data.message) {
            showMessage('error', data.message);
          } else {
            showMessage('error', 'خطای ناشناخته در ذخیره فرم');
          }
        }
      })
      .catch(err => {
        showMessage('error', 'خطا در ارتباط با سرور');
        console.error(err);
      });
    });
  }
  
  // تابع خالص‌سازی تمام فیلدهای عددی در فرم
  function sanitizeAllNumericFields() {
    console.log('Sanitizing all numeric fields before form submission');
    
    // تابع کمکی برای تبدیل اعداد فارسی به انگلیسی و حذف جداکننده‌ها
    function convertToRawNumber(value, fieldType = '', fieldName = '') {
      console.log('Converting to raw number:', {
        value: value,
        fieldType: fieldType,
        fieldName: fieldName,
        valueType: typeof value,
        originalValue: value
      });

      // اگر مقدار خالی یا undefined باشد
      if (value === null || value === undefined || value === '') {
        console.warn(`Empty value detected for ${fieldType} field: ${fieldName}`);
        return false;
      }

      // تبدیل به رشته برای پردازش
      let strValue = String(value);

      // تبدیل اعداد فارسی و عربی به انگلیسی
      const persianDigits = {'۰':'0', '۱':'1', '۲':'2', '۳':'3', '۴':'4', '۵':'5', '۶':'6', '۷':'7', '۸':'8', '۹':'9',
                            '٠':'0', '١':'1', '٢':'2', '٣':'3', '٤':'4', '٥':'5', '٦':'6', '٧':'7', '٨':'8', '٩':'9'};
      
      strValue = strValue.replace(/[۰-۹٠-٩]/g, digit => persianDigits[digit] || digit);
      
      // حذف جداکننده‌های هزارگان و تبدیل نقطه فارسی
      strValue = strValue.replace(/[٬,،]/g, '').replace(/٫/g, '.');
      
      console.log('After character conversion:', strValue);

      // تبدیل به عدد
      let numericValue = parseFloat(strValue);
      
      console.log('After parseFloat:', {
        originalValue: value,
        strValue: strValue,
        numericValue: numericValue,
        isNaN: isNaN(numericValue)
      });

      if (isNaN(numericValue)) {
        console.warn(`Invalid numeric value: ${value} (converted to: ${strValue})`);
        return false;
      }
      
      // اعتبارسنجی مقادیر عددی
      if (fieldType === 'weight') {
        // برای وزن، فقط چک می‌کنیم که عدد مثبت باشد و حداکثر 3 رقم اعشار داشته باشد
        if (numericValue <= 0) {
          console.warn(`Weight validation failed: value <= 0 (${numericValue})`);
          return false;
        }
        // گرد کردن به 3 رقم اعشار
        numericValue = parseFloat(numericValue.toFixed(3));
      } else if (fieldType === 'price') {
        // برای قیمت، فقط چک می‌کنیم که عدد مثبت باشد
        if (numericValue <= 0) {
          console.warn(`Price validation failed: value <= 0 (${numericValue})`);
          return false;
        }
        // گرد کردن به عدد صحیح
        numericValue = Math.round(numericValue);
      }
      
      console.log('Validation passed:', {
        fieldType: fieldType,
        fieldName: fieldName,
        finalValue: numericValue
      });
      
      return numericValue;
    }
    
    // آیا هر فیلدی خطا داشت
    let hasError = false;
    
    // تابع کمکی برای پردازش یک فیلد عددی
    function processNumericField(input) {
      let fieldType = '';
      let fieldName = '';
      
      // استخراج نام محصول برای پیام خطا
      const row = input.closest('.transaction-item-row');
      if (row) {
        const productSelect = row.querySelector('.product-select');
        if (productSelect && productSelect.selectedOptions[0]) {
          fieldName = productSelect.selectedOptions[0].text;
        }
      }
      
      // تشخیص نوع فیلد بر اساس نام
      if (input.name.includes('carat')) fieldType = 'carat';
      else if (input.name.includes('weight')) {
        fieldType = 'weight';
        fieldName += ' - وزن';
      }
      else if (input.name.includes('price') || input.name.includes('amount')) {
        fieldType = 'price';
        fieldName += ' - قیمت واحد';
      }
      
      console.log('Processing field:', {
        name: input.name,
        type: fieldType,
        displayName: fieldName,
        rawValue: input.value
      });

      let value;
      
      // استخراج مقدار عددی فیلد
      if (typeof AutoNumeric !== 'undefined' && AutoNumeric.getAutoNumericElement(input)) {
        try {
          value = AutoNumeric.getNumber(input);
          console.log('AutoNumeric value:', value);
        } catch (e) {
          console.warn(`Error using AutoNumeric for field ${input.name}:`, e);
          value = input.value;
        }
      } else {
        value = input.value;
      }

      // اعتبارسنجی و تبدیل
      const validatedValue = convertToRawNumber(value, fieldType, fieldName);
      
      if (validatedValue === false) {
        input.classList.add('is-invalid');
        // نمایش پیام خطا زیر input
        let feedbackDiv = input.nextElementSibling;
        if (!feedbackDiv || !feedbackDiv.classList.contains('invalid-feedback')) {
          feedbackDiv = document.createElement('div');
          feedbackDiv.className = 'invalid-feedback';
          input.parentNode.insertBefore(feedbackDiv, input.nextSibling);
        }
        if (fieldType === 'weight') {
          feedbackDiv.textContent = `وزن باید عدد مثبت با حداکثر ۳ رقم اعشار باشد (${fieldName})`;
        } else if (fieldType === 'price') {
          feedbackDiv.textContent = `قیمت باید عدد مثبت باشد (${fieldName})`;
        } else if (fieldType === 'carat') {
          feedbackDiv.textContent = `عیار باید عدد معتبر باشد (${fieldName})`;
        } else {
          feedbackDiv.textContent = `مقدار وارد شده معتبر نیست (${fieldName})`;
        }
        feedbackDiv.style.display = 'block';
        return false;
      }
      
      input.classList.remove('is-invalid');
      let feedbackDiv = input.nextElementSibling;
      if (feedbackDiv && feedbackDiv.classList.contains('invalid-feedback')) {
        feedbackDiv.style.display = 'none';
      }
      
      // تنظیم مقدار نهایی در فیلد
      if (input.classList.contains('autonumeric') && typeof AutoNumeric !== 'undefined') {
        AutoNumeric.set(input, validatedValue);
      } else {
        input.value = validatedValue;
      }
      
      console.log(`Field ${input.name} sanitized successfully:`, validatedValue);
      return true;
    }
    
    // ۱. خالص‌سازی فیلدهای اصلی فرم (مانند مظنه)
    document.querySelectorAll('input.autonumeric, input[data-autonumeric-options], input[type="number"]')
      .forEach(input => processNumericField(input));
    
    // ۲. خالص‌سازی تمام فیلدهای عددی اقلام معامله
    document.querySelectorAll('.transaction-item-row').forEach((row, rowIndex) => {
      row.querySelectorAll('input').forEach(input => {
        // تشخیص فیلدهای عددی بر اساس کلاس یا نام
        const isNumericField = 
          input.classList.contains('autonumeric') || 
          input.hasAttribute('data-autonumeric-options') ||
          input.type === 'number' || 
          input.name.includes('price') || 
          input.name.includes('amount') || 
          input.name.includes('weight') || 
          input.name.includes('quantity') || 
          input.name.includes('carat') ||
          input.name.includes('rate') ||
          input.name.includes('percent');
        
        if (isNumericField) {
          // اضافه کردن نام فیلد برای نمایش در پیام خطا
          const productSelect = row.querySelector('.product-select');
          const productName = productSelect ? productSelect.options[productSelect.selectedIndex].text : `ردیف ${rowIndex + 1}`;
          input.setAttribute('data-field-name', `${productName} - ${input.name}`);
          
          processNumericField(input);
        }
      });
    });
    
    // اگر خطایی وجود داشت، مانع از ارسال فرم شو
    if (hasError) {
      showMessage('error', 'لطفاً خطاهای موجود در فرم را اصلاح کنید');
    }
    return !hasError;
  }

  if (!allFields || allFields.length === 0) {
    console.warn('Fields data is not loaded or empty. Dynamic fields may not work.');
  }

  if (!allFormulas || allFormulas.length === 0) {
    console.warn('Formulas data is not loaded or empty. Calculations may not work.');
  }

  function showMessage(type, text) {
    const color = {
      success: '#4caf50',
      error: '#f44336',
      warning: '#ff9800',
      info: '#2196f3'
    }[type] || '#333';

    // اگر متن شامل <li> یا <ul> نیست و شامل <br> است، آن را به لیست تبدیل کن
    let msgHtml = text;
    if (!text.includes('<ul') && !text.includes('<li>') && text.includes('<br>')) {
      const items = text.split('<br>').filter(Boolean);
      if (items.length > 1) {
        msgHtml = '<ul style="margin:0 0 0 20px;padding:0;">' + items.map(item => `<li style='margin-bottom:4px;'>${item}</li>`).join('') + '</ul>';
      }
    }

    // ساخت div پیام
    const msg = document.createElement('div');
    msg.innerHTML = `<span style='font-weight:bold;'>${type === 'success' ? '✔ ' : type === 'error' ? '✖ ' : ''}</span>` + msgHtml +
      `<span style='cursor:pointer;float:left;font-size:18px;margin-right:10px;' onclick='this.parentNode.remove()'>&times;</span>`;
    msg.style.cssText = `
      position:fixed;top:20px;right:20px;z-index:9999;
      background:${color};color:#fff;padding:10px 20px;
      border-radius:5px;box-shadow:0 2px 8px #0002;
      font-size:15px;transition:all .3s;max-width:400px;direction:rtl;text-align:right;
    `;
    document.body.appendChild(msg);
    if (type === 'success') {
      setTimeout(() => { msg.style.opacity = 0; }, 6000);
      setTimeout(() => { msg.remove(); }, 7000);
    }
    // برای خطا، پیام تا زمانی که کاربر نبندد باقی می‌ماند (بدون auto-hide)
    // اسکرول به بالای پیام در صورت خطا
    if (type === 'error') {
      setTimeout(() => { window.scrollTo({top: 0, behavior: 'smooth'}); }, 100);
    }
  }

  document.querySelectorAll('.autonumeric').forEach(el => {
    if (typeof AutoNumeric !== 'undefined') {
      new AutoNumeric(el, { allowDecimalPadding: false, decimalPlaces: 0, digitGroupSeparator: ',', decimalCharacter: '.' });
    } else {
      console.warn('AutoNumeric library not found.');
    }
  });

  const productGroups = {};
  products.forEach(p => { productGroups[p.group] = p.group_name || p.group; });

  function renderItemRow(itemData = null, index) {
    console.log('Rendering item row for index:', index, 'Data:', itemData ? {...itemData} : null);
    const newRowContainer = document.createElement('div');
    newRowContainer.innerHTML = itemRowTemplate.replace(/{index}/g, index);
    const newRowElement = newRowContainer.firstElementChild;

    if (newRowElement) {
        itemsContainer.appendChild(newRowElement);
        
        // ابتدا تمام فیلدها را مقداردهی کنیم، سپس اتونامریک را اعمال کنیم
        // مرحله 1: تعیین نوع محصول و گروه آن
        let productGroup = '';
        let selectedProduct = null;
        let productCategoryCode = '';
        
        if (itemData && itemData.product_id) {
            selectedProduct = products.find(p => p.id == itemData.product_id);
            if (selectedProduct) {
                // تلاش برای استخراج کد دسته‌بندی از اطلاعات محصول
                // ابتدا سعی می‌کنیم از category.code استفاده کنیم، سپس base_category و در نهایت از group
                productCategoryCode = '';
                
                if (selectedProduct.category) {
                    if (typeof selectedProduct.category === 'object') {
                        // اگر category یک آبجکت است
                        productCategoryCode = selectedProduct.category.code || 
                                          selectedProduct.category.base_category || '';
                    } else if (typeof selectedProduct.category === 'string') {
                        // اگر category یک رشته است
                        productCategoryCode = selectedProduct.category;
                    }
                }
                
                // اگر هنوز مشخص نشده، از category_id استفاده کنیم
                if (!productCategoryCode && selectedProduct.category_id) {
                    // جستجوی کد دسته‌بندی در categoryIdToBaseCategory
                    if (window.categoryIdToBaseCategory && 
                        window.categoryIdToBaseCategory[selectedProduct.category_id]) {
                        productCategoryCode = window.categoryIdToBaseCategory[selectedProduct.category_id];
                        console.log(`Found category code ${productCategoryCode} for category_id ${selectedProduct.category_id} from mapping`);
                    } else {
                        // اگر نتوانستیم کد دسته‌بندی را پیدا کنیم، از group استفاده می‌کنیم
                        productCategoryCode = selectedProduct.group || 'manufactured';
                        console.warn(`Could not find category code for ID ${selectedProduct.category_id}, using default: ${productCategoryCode}`);
                    }
                }
                
                // بررسی نهایی و اطمینان از اینکه گروه محصول به درستی تشخیص داده شده است
                console.log(`Product ${selectedProduct.name} (ID: ${selectedProduct.id}) - Category ID: ${selectedProduct.category_id}, Detected category code: ${productCategoryCode}`);
                
                productGroup = getCategoryGroup(productCategoryCode);
                
                // ذخیره اطلاعات مالیات محصول برای استفاده در محاسبات
                selectedProduct.tax_enabled = selectedProduct.tax_enabled || false;
                selectedProduct.tax_rate = selectedProduct.tax_rate || 0;
                selectedProduct.vat_enabled = selectedProduct.vat_enabled || false;
                selectedProduct.vat_rate = selectedProduct.vat_rate || 0;
                
                console.log('Product found:', selectedProduct.name, 'Group:', productGroup, 'Category Code:', productCategoryCode, 'Tax:', selectedProduct.tax_enabled, 'VAT:', selectedProduct.vat_enabled);
            } else {
                console.warn(`Product with ID ${itemData.product_id} was not found in products list!`);
            }
        }
        
        // مرحله 2: ایجاد کپی از داده‌ها برای جلوگیری از تغییر ناخواسته
        const normalizedData = { ...(itemData || {}) };
        
        // نمایش اطلاعات کامل آیتم در کنسول برای دیباگ
        console.log('Item data for debugging:', normalizedData);
        
        // مرحله 3: پر کردن select محصول و اتصال رویدادها
        const productSelect = newRowElement.querySelector('.product-select');
        if (productSelect) {
            // پر کردن لیست محصولات و ذخیره مقدار انتخاب شده
            const selectedValue = fillProductSelect(productSelect, normalizedData.product_id);
            
            // تنظیم مستقیم مقدار محصول اگر در لیست نبود
            if (normalizedData.product_id && selectedValue != normalizedData.product_id) {
                productSelect.value = normalizedData.product_id;
                console.log('Manually set product ID to:', normalizedData.product_id);
                
                // بررسی کنیم که آیا محصول انتخاب شده و data-code آن صحیح است
                const selectedOption = productSelect.querySelector(`option[value="${normalizedData.product_id}"]`);
                if (selectedOption) {
                    // اطمینان از وجود data-code برای محصول انتخاب شده
                    if (!selectedOption.dataset.code) {
                        // یافتن محصول در لیست محصولات
                        const product = products.find(p => p.id == normalizedData.product_id);
                        if (product) {
                            // تنظیم data-code از محصول یا دسته‌بندی آن
                            let categoryCode = '';
                            
                            if (product.category) {
                                if (typeof product.category === 'object') {
                                    categoryCode = product.category.code || 
                                                 product.category.base_category || '';
                                } else if (typeof product.category === 'string') {
                                    categoryCode = product.category;
                                }
                            }
                            
                            // اگر هنوز مشخص نشده، از category_id استفاده کنیم
                            if (!categoryCode && product.category_id) {
                                categoryCode = product.category_id.toString();
                            }
                            
                            if (categoryCode) {
                                selectedOption.setAttribute('data-code', categoryCode);
                                console.log(`Set data-code=${categoryCode} for product ID ${normalizedData.product_id}`);
                            }
                        }
                    }
                }
            }
            
            // تریگر رویداد change فوری برای محصول انتخاب شده
            if (normalizedData.product_id) {
                try {
                    // ابتدا container فیلدهای داینامیک را برای محصول انتخاب شده آماده کنیم
                    const dynamicFieldsContainer = newRowElement.querySelector(`#dynamic-fields-${index}`);
                    if (dynamicFieldsContainer && productCategoryCode) {
                        // تعیین گروه اصلی محصول
                        const mainGroup = getCategoryGroup(productCategoryCode);
                        console.log(`Pre-rendering fields for category: ${productCategoryCode}, main group: ${mainGroup}`);
                        
                        // رندر کردن فیلدهای مخصوص این گروه
                        dynamicFieldsContainer.innerHTML = getFieldsHtmlByGroup(productCategoryCode, index);
                        
                        // فراخوانی loadAssayOffices برای پر کردن سلکت‌های مراکز ری‌گیری
                        loadAssayOffices();
                        
                        // حالا فیلدها را با مقادیر پر کنیم - قبل از هر رویدادی
                        console.log(`Found ${dynamicFieldsContainer.querySelectorAll('input, select').length} inputs in dynamic container to initialize`);
                        
                        dynamicFieldsContainer.querySelectorAll('input, select').forEach(input => {
                            if (!input.name) return;
                            
                            const nameMatch = input.name.match(/items\[\d+\]\[(.+?)\]/);
                            if (nameMatch && nameMatch[1]) {
                                const fieldName = nameMatch[1];
                                
                                if (normalizedData.hasOwnProperty(fieldName) && 
                                    normalizedData[fieldName] !== null && 
                                    normalizedData[fieldName] !== undefined) {
                                    console.log(`Setting dynamic field: ${fieldName} = ${normalizedData[fieldName]}`);
                                    
                                    if (input.type === 'checkbox') {
                                        input.checked = !!normalizedData[fieldName];
                                    } else if (input.tagName === 'SELECT') {
                                        input.value = normalizedData[fieldName];
                                    } else {
                                        // برای اطمینان از تنظیم درست مقدار، آن را به صورت صریح تنظیم می‌کنیم
                                        input.value = normalizedData[fieldName];
                                        // علامت‌گذاری برای مقداردهی بعدی توسط AutoNumeric
                                        input.dataset.initialValue = normalizedData[fieldName];
                                    }
                                }
                            }
                        });
                    }
                    
                    // صبر کوتاه قبل از تنظیم مقادیر عددی
                    setTimeout(() => {
                        // پیش از اعمال AutoNumeric، مقادیر اولیه را به صورت خام به المان‌ها تنظیم کنیم
                        newRowElement.querySelectorAll('input[data-initial-value]').forEach(input => {
                            try {
                                const rawValue = input.dataset.initialValue;
                                if (rawValue) {
                                    // تبدیل به عدد خام
                                    const cleanValue = rawValue.toString().replace(/[^\d.-]/g, '');
                                    const numValue = parseFloat(cleanValue);
                                    
                                    if (!isNaN(numValue)) {
                                        console.log(`Setting raw value for ${input.name} to ${numValue}`);
                                        // تنظیم مستقیم مقدار عددی (قبل از اعمال AutoNumeric)
                                        input.value = numValue.toString();
                                    }
                                }
                            } catch(e) {
                                console.error(`Error setting raw value for ${input.name}:`, e);
                            }
                        });
                        
                        // اجرای autonumeric روی همه فیلدها
                        initializeAllAutonumerics(newRowElement);
                        
                        // تأخیر کوتاه قبل از محاسبه فرمول‌ها تا اطمینان حاصل شود که AutoNumeric مقادیر را به درستی اعمال کرده
                        setTimeout(() => {
                            // ابتدا فرمول‌ها را برای مقادیر اولیه محاسبه کنیم
                            if (productCategoryCode) {
                                const groupFormulas = getFormulasForCategory(productCategoryCode);
                                calculateFormulasForRow(dynamicFieldsContainer, groupFormulas, index, selectedProduct);
                            }
                        }, 200);
                    }, 100);
                    
                    // حذف فراخوانی رویداد change برای جلوگیری از بازنویسی مقادیر
                    // productSelect.dispatchEvent(new Event('change'));
                } catch (e) {
                    console.error('Error during product selection:', e);
                }
            }
            
            // رویداد تغییر محصول
            productSelect.addEventListener('change', function() {
                const selectProductId = this.value;
                const selectProduct = products.find(p => p.id == selectProductId);
                const selectedOption = this.options[this.selectedIndex];
                console.log('Product select changed to:', selectProductId, selectProduct?.name);
                
                if (selectProduct) {
                    // استفاده از data-code و data-group از option انتخاب شده اگر موجود باشد
                    let categoryCode = '';
                    let mainGroup = '';
                    
                    if (selectedOption) {
                        categoryCode = selectedOption.dataset.code || '';
                        mainGroup = selectedOption.dataset.group || '';
                    }
                    
                    // اگر data-code در option نبود، سعی کن از اطلاعات محصول استخراج کنی
                    if (!categoryCode) {
                        if (selectProduct.category) {
                            if (typeof selectProduct.category === 'object') {
                                categoryCode = selectProduct.category.code || 
                                           selectProduct.category.base_category || '';
                            } else if (typeof selectProduct.category === 'string') {
                                categoryCode = selectProduct.category;
                            }
                        }
                        
                        // اگر از category نتوانستیم تشخیص دهیم، از category_id استفاده کنیم
                        if (!categoryCode && selectProduct.category_id) {
                            if (window.categoryIdToBaseCategory && 
                                window.categoryIdToBaseCategory[selectProduct.category_id]) {
                                categoryCode = window.categoryIdToBaseCategory[selectProduct.category_id];
                            } else {
                                categoryCode = selectProduct.group || 'manufactured';
                            }
                        }
                        
                        // اگر هنوز هم خالی است، از group یا مقدار پیش‌فرض استفاده کنیم
                        if (!categoryCode) {
                            categoryCode = selectProduct.group || 'manufactured';
                        }
                        
                        // تعیین mainGroup اگر در data-group نبود
                        if (!mainGroup) {
                            mainGroup = getCategoryGroup(categoryCode);
                        }
                    }
                    
                    console.log('Product category determined:', categoryCode, 'Main group:', mainGroup);
                    
                    // پاکسازی فیلدهای داینامیک قبلی
                    const dynamicFieldsContainer = newRowElement.querySelector(`#dynamic-fields-${index}`);
                    if (dynamicFieldsContainer) {
                        // تعیین گروه اصلی محصول
                        const mainGroup = getCategoryGroup(categoryCode);
                        console.log('Product category determined:', categoryCode, 'Main group:', mainGroup);
                        
                        // ذخیره موقت مقادیر قبلی فیلدها از normalizedData (مهم)
                        const savedValues = {...normalizedData};
                        
                        // رندر کردن فیلدهای مخصوص این گروه
                        dynamicFieldsContainer.innerHTML = getFieldsHtmlByGroup(categoryCode, index);
                        
                        // نگهداری مقادیر قبلی فیلدها - استفاده از savedValues به جای normalizedData
                        // پر کردن مقادیر فیلدهای دینامیک از savedValues
                        dynamicFieldsContainer.querySelectorAll('input, select').forEach(input => {
                            if (!input.name) return;
                            
                            const nameMatch = input.name.match(/items\[\d+\]\[(.+?)\]/);
                            if (nameMatch && nameMatch[1]) {
                                const fieldName = nameMatch[1];
                                
                                if (savedValues.hasOwnProperty(fieldName) && 
                                    savedValues[fieldName] !== null && 
                                    savedValues[fieldName] !== undefined) {
                                    console.log(`Setting field from saved data: ${fieldName} = ${savedValues[fieldName]}`);
                                    
                                    if (input.type === 'checkbox') {
                                        input.checked = !!savedValues[fieldName];
                                    } else if (input.tagName === 'SELECT') {
                                        input.value = savedValues[fieldName];
                                    } else {
                                        input.value = savedValues[fieldName];
                                    }
                                }
                            }
                        });
                        
                        initializeAllAutonumerics(dynamicFieldsContainer);
                        bindCalculationEvents(dynamicFieldsContainer, categoryCode, index);
                        
                        // فراخوانی loadAssayOffices بعد از ایجاد فیلدهای دینامیک
                        loadAssayOffices();
                        
                        // اجرای محاسبات اولیه با مظنه موجود
                        const mazanehInput = document.querySelector('[name="mazaneh_price"]');
                        if (mazanehInput && mazanehInput.value) {
                            setTimeout(() => {
                                const groupFormulas = getFormulasForCategory(categoryCode);
                                calculateFormulasForRow(dynamicFieldsContainer, groupFormulas, index, selectProduct);
                            }, 200);
                        }
                    }
                }
                updateSummaryFields();
            });
        } else {
            console.error('Product select element not found in new row.');
        }
        
        // بروز جمع‌ها
        setTimeout(() => {
            updateSummaryFields();
        }, 500);
        
        return newRowElement;
    } else {
        console.error('Failed to create new item row from template.');
        showMessage('error', 'خطا در افزودن ردیف جدید.');
        return null;
    }
}

// کمک تابع برای یافتن فرمول‌های مرتبط با یک دسته‌بندی
function getFormulasForCategory(categoryCode) {
    // نرمال‌سازی کد دسته‌بندی
    const normalizedCode = categoryCode ? categoryCode.toString().trim().toLowerCase() : '';
    const mainGroup = getCategoryGroup(normalizedCode);
    
    console.log(`Finding formulas for category: ${categoryCode}, main group: ${mainGroup}`);
    
    if (!mainGroup || mainGroup !== 'melted' && mainGroup !== 'manufactured' && mainGroup !== 'coin' && 
        mainGroup !== 'goldbullion' && mainGroup !== 'silverbullion' && mainGroup !== 'jewelry') {
        console.warn(`Unable to determine valid product group for formulas: ${categoryCode} -> ${mainGroup}`);
        return [];
    }
    
    // ابتدا بر اساس کد دقیق دسته‌بندی جستجو کنیم
    let groupFormulas = (window.allFormulasData?.formulas || []).filter(f => 
        f.group && 
        f.group.toString().trim().toLowerCase() === normalizedCode
    );
    
    // اگر فرمولی پیدا نشد، بر اساس گروه اصلی جستجو کنیم
    if (groupFormulas.length === 0 && mainGroup) {
        groupFormulas = (window.allFormulasData?.formulas || []).filter(f => 
            f.group && 
            f.group.toString().trim().toLowerCase() === mainGroup.trim().toLowerCase()
        );
        console.log(`No formulas found for category code ${normalizedCode}, using main group ${mainGroup} with ${groupFormulas.length} formulas`);
    }
    
    return groupFormulas;
}

function bindCalculationEvents(container, categoryCode, currentIndex) {
    console.log('Binding calculation events for category:', categoryCode, 'index:', currentIndex);
    
    // استفاده از تابع کمکی برای پیدا کردن فرمول‌های مرتبط
    const groupFormulas = getFormulasForCategory(categoryCode);
    
    if (!groupFormulas || groupFormulas.length === 0) {
        console.warn(`No formulas found for category ${categoryCode}`);
        return;
    }
    
    console.log(`Found ${groupFormulas.length} formulas for binding`);
    
    // همه فیلدهای ورودی که در هر فرمول به عنوان fields آمده‌اند را پیدا کن
    const fieldsToWatch = Array.from(new Set(groupFormulas.flatMap(f => (f.fields || []))));
    
    // فیلدهای مالیات و مظنه را جدا پردازش می‌کنیم
    const globalFields = ['mazaneh_price', 'product_tax_enabled', 'product_tax_rate', 'product_vat_enabled', 'product_vat_rate'];
    
    fieldsToWatch.forEach(fieldName => {
        if (!fieldName) return;
        
        // اگر فیلد یک فیلد عمومی (نه items[]) است، از کل form پیدا کنیم
        if (globalFields.includes(fieldName)) {
            const globalInput = document.querySelector(`[name="${fieldName}"]`);
            if (globalInput) {
                console.log(`Binding change event to global field ${fieldName}`);
                globalInput.addEventListener('input', () => {
                    // اجرای فرمول‌ها برای تمام ردیف‌ها
                    document.querySelectorAll('.transaction-item-row').forEach((row, idx) => {
                        const dynamicFieldsContainer = row.querySelector(`#dynamic-fields-${idx}`);
                        if (dynamicFieldsContainer) {
                            const productSelect = row.querySelector('.product-select');
                            if (productSelect && productSelect.value) {
                                const rowProduct = products.find(p => p.id == productSelect.value);
                                if (rowProduct) {
                                    // استخراج کد دسته‌بندی محصول
                                    let productCategoryCode = '';
                                    
                                    if (rowProduct.category) {
                                        if (typeof rowProduct.category === 'object') {
                                            productCategoryCode = rowProduct.category.code || 
                                                             rowProduct.category.base_category || '';
                                        } else if (typeof rowProduct.category === 'string') {
                                            productCategoryCode = rowProduct.category;
                                        }
                                    }
                                    
                                    // اگر هنوز کد دسته‌بندی مشخص نشده، از category_id استفاده کنیم
                                    if (!productCategoryCode && rowProduct.category_id) {
                                        if (window.categoryIdToBaseCategory && 
                                            window.categoryIdToBaseCategory[rowProduct.category_id]) {
                                            productCategoryCode = window.categoryIdToBaseCategory[rowProduct.category_id];
                                        } else {
                                            productCategoryCode = rowProduct.group || 'manufactured';
                                        }
                                    }
                                    
                                    // اگر هنوز هم خالی است، از group یا مقدار پیش‌فرض استفاده کنیم
                                    if (!productCategoryCode) {
                                        productCategoryCode = rowProduct.group || 'manufactured';
                                    }
                                    
                                    const rowFormulas = getFormulasForCategory(productCategoryCode);
                                    calculateFormulasForRow(dynamicFieldsContainer, rowFormulas, idx, rowProduct);
                                }
                            }
                        }
                    });
                });
            } else {
                console.warn(`Global field ${fieldName} not found for binding`);
            }
        } else {
            // فیلدهای محصول در ردیف فعلی
            const inputElement = container.querySelector(`[name='items[${currentIndex}][${fieldName}]']`);
            if (inputElement) {
                console.log(`Binding change event to field ${fieldName}`);
                inputElement.addEventListener('input', () => {
                    // یافتن محصول انتخاب شده در این ردیف
                    const row = container.closest('.transaction-item-row');
                    const productSelect = row?.querySelector('.product-select');
                    let rowProduct = null;
                    if (productSelect && productSelect.value) {
                        rowProduct = products.find(p => p.id == productSelect.value);
                    }
                    calculateFormulasForRow(container, groupFormulas, currentIndex, rowProduct);
                });
            } else {
                console.warn(`Field ${fieldName} not found in container for binding`);
            }
        }
    });
}

function calculateFormulasForRow(container, groupFormulas, currentIndex, selectedProduct = null) {
    // ساخت آرایه rowData که حاوی تمام مقادیر فیلدهای فرم برای استفاده در فرمول‌ها است
    const rowData = {};
    
    // آیا این ویرایش یک معامله موجود است (نه یک معامله جدید)؟
    const isEditMode = window.transactionItemsData && Array.isArray(window.transactionItemsData) && window.transactionItemsData.length > 0;
    
    // لاگ برای اشکال‌زدایی
    console.log('Calculating formulas for row', currentIndex, 'Formula count:', groupFormulas?.length || 0, 'Edit mode:', isEditMode);
    
    // مقداردهی مستقیم برخی از فیلدهای ضروری از dataset.initialValue
    const row = container.closest('.transaction-item-row');
    if (row) {
        row.querySelectorAll('input[data-initial-value]').forEach(input => {
            const nameMatch = input.name.match(/items\[(\d+)\]\[(.+?)\]/);
            if (nameMatch && nameMatch[1] == currentIndex) {
                const fieldName = nameMatch[2];
                const rawValue = input.dataset.initialValue;
                if (rawValue) {
                    // تبدیل به عدد خام
                    const cleanValue = rawValue.toString().replace(/[^\d.-]/g, '');
                    const numValue = parseFloat(cleanValue);
                    
                    if (!isNaN(numValue)) {
                        console.log(`Direct assignment: ${fieldName} = ${numValue}`);
                        rowData[fieldName] = numValue;
                    }
                }
            }
        });
    }
    
    // تمام ورودی‌های موجود در این ردیف را جمع‌آوری کن
    container.querySelectorAll('input, select').forEach(input => {
        if (!input.name) return; // فقط اگر name دارد پردازش کن
        
        const nameMatch = input.name.match(/items\[(\d+)\]\[(.+?)\]/);
        if (!nameMatch || nameMatch[1] != currentIndex) return; // فقط فیلدهای این ردیف
        
        const fieldName = nameMatch[2];
        
        // اگر این فیلد قبلاً از dataset.initialValue تنظیم شده، آن را پردازش نکن
        if (rowData[fieldName] !== undefined) {
            return;
        }
        
        let value;
        
        // اولویت با استفاده از dataset.initialValue اگر موجود باشد
        if (input.dataset && input.dataset.initialValue) {
            try {
                value = parseFloat(input.dataset.initialValue.toString().replace(/[٬,]/g, '')) || 0;
                console.log(`Using initialValue for ${fieldName}: ${value}`);
            } catch(e) {
                console.warn(`Error parsing initialValue for ${fieldName}:`, e);
                value = 0;
            }
        }
        // استفاده از AutoNumeric
        else if (input.classList.contains('autonumeric') && typeof AutoNumeric !== 'undefined') {
            try {
                // سعی کن مقدار عددی را از AutoNumeric بگیر
                const anElement = AutoNumeric.getAutoNumericElement(input);
                if (anElement) {
                    value = anElement.getNumber();
                } else {
                    // اگر وجود نداشت، سعی کن بر اساس فرمت تجزیه کنی
                    value = parseFloat(input.value.replace(/٬|,/g, '')) || 0;
                }
            } catch (e) {
                console.warn(`Error getting AutoNumeric value for ${fieldName}:`, e);
                value = parseFloat(input.value.replace(/٬|,/g, '')) || 0;
            }
        } else {
            // برای فیلدهای معمولی، سعی کن مقدار عددی را استخراج کنی
            value = parseFloat(input.value.replace(/٬|,/g, '')) || 0;
        }
        
        // حتی اگر مقدار NaN بود، باز هم صفر را استفاده کن
        if (isNaN(value)) value = 0;
        
        rowData[fieldName] = value;
    });
    
    // اگر محصول انتخاب شده نبود، محاسبات را انجام نده
    if (!selectedProduct) {
        console.warn('No product selected, skipping formula calculations');
        return;
    }
    
    // بررسی صحیح بودن ویژگی‌های مالیات محصول
    if (typeof selectedProduct.tax_enabled === 'undefined') selectedProduct.tax_enabled = false;
    if (typeof selectedProduct.tax_rate === 'undefined') selectedProduct.tax_rate = 0;
    if (typeof selectedProduct.vat_enabled === 'undefined') selectedProduct.vat_enabled = false;
    if (typeof selectedProduct.vat_rate === 'undefined') selectedProduct.vat_rate = 0;
    
    // مقداردهی داینامیک مالیات و ارزش افزوده از مدل محصول
    rowData['product_tax_enabled'] = selectedProduct.tax_enabled ? 1 : 0;
    rowData['product_tax_rate'] = selectedProduct.tax_rate ? parseFloat(selectedProduct.tax_rate) : 0;
    rowData['product_vat_enabled'] = selectedProduct.vat_enabled ? 1 : 0;
    rowData['product_vat_rate'] = selectedProduct.vat_rate ? parseFloat(selectedProduct.vat_rate) : 0;
    
    // دریافت گروه محصول برای تأیید شوندگی با مدل TransactionItem
    let productCategoryCode = selectedProduct.category?.code || 
                         selectedProduct.category?.base_category || 
                         selectedProduct.group || 'manufactured';
    const productGroup = getCategoryGroup(productCategoryCode);
    
    console.log('Product for calculations:', selectedProduct.name, 'Category:', productCategoryCode, 'Group:', productGroup, 
                'Tax enabled:', rowData['product_tax_enabled'], 'VAT enabled:', rowData['product_vat_enabled']);
    
    // اضافه کردن تمام فیلدهای مورد نیاز بر اساس گروه محصول
    const requiredFields = {};
    requiredFields['melted'] = [
        'item_carat_melted', 
        'item_weight_scale_melted', 
        'item_weight_750_melted', 
        'item_unit_price_melted', 
        'item_total_price_melted',
        'item_profit_percent_melted',
        'item_profit_amount_melted',
        'item_fee_percent_melted',
        'item_fee_amount_melted',
        'item_assay_office_melted',
        'item_appurtenances_melted',
        'item_appurtenances_type_melted',
        'item_workshop_name_melted'
    ];
    requiredFields['manufactured'] = [
        'item_carat_manufactured', 
        'item_weight_scale_manufactured', 
        'item_weight_750_manufactured', 
        'item_unit_price_manufactured', 
        'item_total_price_manufactured',
        'item_profit_percent_manufactured',
        'item_profit_amount_manufactured',
        'item_fee_percent_manufactured',
        'item_fee_amount_manufactured',
        'item_manufacturing_fee_rate_manufactured',
        'item_manufacturing_fee_amount_manufactured',
        'item_appurtenances_manufactured',
        'item_appurtenances_type_manufactured',
        'item_workshop_name_manufactured' 
    ];
    
    // تضمین وجود تمام فیلدهای مورد نیاز گروه فعلی
    if (requiredFields[productGroup]) {
        requiredFields[productGroup].forEach(field => {
            if (rowData[field] === undefined) {
                console.log(`Added missing field ${field} with default value 0`);
                rowData[field] = 0;
                
                // در صورت وجود فیلد، آن را در فرم نیز مقداردهی کنیم
                const fieldInput = container.querySelector(`[name="items[${currentIndex}][${field}]"]`);
                if (fieldInput && !fieldInput.value) {
                    if (fieldInput.classList.contains('autonumeric') && typeof AutoNumeric !== 'undefined') {
                        AutoNumeric.set(fieldInput, 0);
                    } else {
                        fieldInput.value = "0";
                    }
                }
            }
        });
    }
    
    // اطمینان از دریافت قیمت مظنه
    const mazanehInput = document.querySelector('[name="mazaneh_price"]');
    if (mazanehInput) {
        try {
            // سعی کن مقدار عددی را از AutoNumeric بگیر
            const anElement = AutoNumeric.getAutoNumericElement(mazanehInput);
            if (anElement) {
                rowData['mazaneh_price'] = anElement.getNumber();
            } else {
                rowData['mazaneh_price'] = parseFloat(mazanehInput.value.replace(/٬|,/g, '')) || 0;
            }
        } catch (e) {
            console.warn('Error getting mazaneh price:', e);
            rowData['mazaneh_price'] = parseFloat(mazanehInput.value.replace(/٬|,/g, '')) || 0;
        }
    } else {
        rowData['mazaneh_price'] = 0;
    }
    
    // بررسی اینکه آیا فرمول داریم
    if (!groupFormulas || groupFormulas.length === 0) {
        console.warn(`No formulas found for calculation.`);
        return;
    }
    
    console.log('Row data before formula calculation:', { ...rowData });
    
    // در حالت ویرایش، اجازه نده فرمول‌ها مقادیر اولیه را بازنویسی کنند
    if (isEditMode) {
        console.log("Edit mode: Skipping most formulas to preserve initial values");
        // فقط محاسبات جانبی مانند مالیات و ارزش افزوده را انجام بده
        const taxFormulas = groupFormulas.filter(f => 
            f.output_field === 'item_general_tax_manufactured' || 
            f.output_field === 'item_vat_manufactured'
        );
        
        if (taxFormulas.length > 0) {
            console.log(`Running only ${taxFormulas.length} tax-related formulas`);
            for (const formula of taxFormulas) {
                try {
                    // بررسی وجود تمام فیلدهای مورد نیاز
                    if (!formula.fields || !formula.output_field || !formula.formula) {
                        console.warn(`Formula ${formula.id} (${formula.name}) has missing required properties.`);
                        continue;
                    }
                    
                    // جایگزینی متغیرها در فرمول
                    let formulaStr = formula.formula;
                    
                    // روش جایگزینی پیشرفته - ابتدا فیلدهای با نام‌های طولانی‌تر را جایگزین کنیم
                    const sortedKeys = Object.keys(rowData).sort((a, b) => b.length - a.length);
                    
                    for (const key of sortedKeys) {
                        // استفاده از الگوی regex دقیق‌تر به همراه word boundary
                        const regex = new RegExp(`\\b${key}\\b`, 'g');
                        formulaStr = formulaStr.replace(regex, rowData[key]);
                    }
                    
                    console.log(`Formula ${formula.name} (${formula.id}):`, formulaStr);
                    
                    // ارزیابی فرمول در یک بلوک try-catch
                    let result;
                    try {
                        result = eval(formulaStr);
                    } catch (e) {
                        console.error(`Error evaluating formula ${formula.id} (${formula.name}):`, e, 'Formula:', formulaStr);
                        // اگر خطا رخ داد، از محاسبه خارج شو
                        continue;
                    }
                    
                    // گرد کردن نتیجه اگر عدد است
                    if (!isNaN(result)) {
                        if (formula.output_field.includes('_weight_')) {
                            // وزن رو با 3 رقم اعشار گرد کنیم
                            result = parseFloat(result.toFixed(3));
                        } else if (formula.output_field.includes('_percent_')) {
                            // درصد را با 2 رقم اعشار گرد کنیم
                            result = parseFloat(result.toFixed(2));
                        } else if (formula.output_field.includes('_price_') || formula.output_field.includes('_amount_')) {
                            // قیمت‌ها و مبالغ را گرد کنیم
                            result = Math.round(result);
                        }
                    }
                    
                    // پیدا کردن فیلد خروجی
                    const rowElement = container.closest('.transaction-item-row');
                    const outputField = rowElement.querySelector(`[name="items[${currentIndex}][${formula.output_field}]"]`);
                    
                    if (outputField) {
                        // مقداردهی نتیجه
                        if (outputField.classList.contains('autonumeric') && typeof AutoNumeric !== 'undefined') {
                            AutoNumeric.set(outputField, result);
                        } else {
                            outputField.value = result;
                        }
                        
                        // بروزرسانی مقدار در rowData برای استفاده در فرمول‌های بعدی
                        rowData[formula.output_field] = result;
                        
                        console.log(`Set ${formula.output_field} = ${result}`);
                    } else {
                        console.warn(`Output field ${formula.output_field} not found in the container.`);
                    }
                } catch (e) {
                    console.error(`Error calculating formula ${formula.id} (${formula.name}):`, e, formula);
                }
            }
        }
    } else {
        // در حالت معامله جدید، تمام فرمول‌ها را اجرا کن
        // دو بار فرمول‌ها را اجرا می‌کنیم تا مطمئن شویم همه مقادیر به درستی محاسبه شده‌اند
        // این برای حل مشکل وابستگی بین فرمول‌ها است
        for (let repeat = 0; repeat < 2; repeat++) {
            for (const formula of groupFormulas) {
                try {
                    // بررسی وجود تمام فیلدهای مورد نیاز
                    if (!formula.fields || !formula.output_field || !formula.formula) {
                        console.warn(`Formula ${formula.id} (${formula.name}) has missing required properties.`);
                        continue;
                    }
                    
                    // چک کنیم که آیا تمام فیلدهای مورد نیاز فرمول در rowData وجود دارند
                    let allFieldsExist = true;
                    for (const field of formula.fields) {
                        if (rowData[field] === undefined) {
                            console.warn(`Field ${field} required by formula ${formula.name} is missing. Setting to 0.`);
                            rowData[field] = 0;
                        }
                    }
                    
                    if (!allFieldsExist) {
                        console.warn(`Skipping formula ${formula.name} due to missing required fields.`);
                        continue;
                    }
                    
                    // جایگزینی متغیرها در فرمول
                    let formulaStr = formula.formula;
                    
                    // روش جایگزینی پیشرفته - ابتدا فیلدهای با نام‌های طولانی‌تر را جایگزین کنیم
                    const sortedKeys = Object.keys(rowData).sort((a, b) => b.length - a.length);
                    
                    for (const key of sortedKeys) {
                        // استفاده از الگوی regex دقیق‌تر به همراه word boundary
                        const regex = new RegExp(`\\b${key}\\b`, 'g');
                        formulaStr = formulaStr.replace(regex, rowData[key]);
                    }
                    
                    console.log(`Formula ${formula.name} (${formula.id}):`, formulaStr);
                    
                    // ارزیابی فرمول در یک بلوک try-catch
                    let result;
                    try {
                        result = eval(formulaStr);
                    } catch (e) {
                        console.error(`Error evaluating formula ${formula.id} (${formula.name}):`, e, 'Formula:', formulaStr);
                        // اگر خطا رخ داد، از محاسبه خارج شو
                        continue;
                    }
                    
                    // گرد کردن نتیجه اگر عدد است
                    if (!isNaN(result)) {
                        if (formula.output_field.includes('_weight_')) {
                            // وزن رو با 3 رقم اعشار گرد کنیم
                            result = parseFloat(result.toFixed(3));
                        } else if (formula.output_field.includes('_percent_')) {
                            // درصد را با 2 رقم اعشار گرد کنیم
                            result = parseFloat(result.toFixed(2));
                        } else if (formula.output_field.includes('_price_') || formula.output_field.includes('_amount_')) {
                            // قیمت‌ها و مبالغ را گرد کنیم
                            result = Math.round(result);
                        }
                    }
                    
                    // پیدا کردن فیلد خروجی
                    const rowElement = container.closest('.transaction-item-row');
                    const outputField = rowElement.querySelector(`[name="items[${currentIndex}][${formula.output_field}]"]`);
                    
                    if (outputField) {
                        // مقداردهی نتیجه
                        if (outputField.classList.contains('autonumeric') && typeof AutoNumeric !== 'undefined') {
                            AutoNumeric.set(outputField, result);
                        } else {
                            outputField.value = result;
                        }
                        
                        // بروزرسانی مقدار در rowData برای استفاده در فرمول‌های بعدی
                        rowData[formula.output_field] = result;
                        
                        console.log(`Set ${formula.output_field} = ${result}`);
                    } else {
                        console.warn(`Output field ${formula.output_field} not found in the container.`);
                    }
                } catch (e) {
                    console.error(`Error calculating formula ${formula.id} (${formula.name}):`, e, formula);
                }
            }
        }
    }
    
    // بعد از محاسبه همه فرمول‌ها، جمع‌ها را بروز کن
    updateSummaryFields();
}

function addNewEmptyItemRow() {
      const newRow = renderItemRow(null, itemIndex); // Render an empty row
      if (newRow) {
          itemIndex++; // Only increment if row was successfully added
      }
      updateSummaryFields();
  }

  addItemButton.addEventListener('click', addNewEmptyItemRow);

  itemsContainer.addEventListener('click', function (e) {
    if (e.target.classList.contains('remove-item-btn')) {
      e.target.closest('.transaction-item-row').remove();
      updateSummaryFields();
      if (window.MESSAGES && MESSAGES.transaction_deleted) {
          showMessage('success', MESSAGES.transaction_deleted);
      } else {
          showMessage('success', 'ردیف حذف شد.');
      }
    }
  });

  function fillProductSelect(selectElement, selectedId = null) {
    if (!selectElement) return null;
    
    console.log('Filling product select with data, selected ID:', selectedId);
    
    // خالی کردن لیست
    selectElement.innerHTML = '<option value="">انتخاب محصول</option>';
    
    // لیست همه محصولات
    const allProducts = [];
    
    // استخراج اطلاعات گروه برای همه محصولات
    if (Array.isArray(products)) {
        products.forEach(product => {
            // استخراج کد دسته‌بندی محصول
            let productCategoryCode = '';
            
            if (product.category) {
                if (typeof product.category === 'object') {
                    productCategoryCode = product.category.code || 
                                       product.category.base_category || '';
                } else if (typeof product.category === 'string') {
                    productCategoryCode = product.category;
                }
            }
            
            // اگر هنوز مشخص نشده، از category_id استفاده کنیم
            if (!productCategoryCode && product.category_id) {
                if (window.categoryIdToBaseCategory && 
                    window.categoryIdToBaseCategory[product.category_id]) {
                    productCategoryCode = window.categoryIdToBaseCategory[product.category_id];
                    console.log(`Product: ${product.name}, Category ID: ${product.category_id}, Mapped to: ${productCategoryCode}`);
                } else {
                    productCategoryCode = product.group || 'manufactured';
                    console.warn(`Product: ${product.name}, Category ID: ${product.category_id} - No mapping found, using default: ${productCategoryCode}`);
                }
            }
            
            // اگر هنوز هم خالی است، از group یا مقدار پیش‌فرض استفاده کنیم
            if (!productCategoryCode) {
                productCategoryCode = product.group || 'manufactured';
                console.warn(`Product: ${product.name} - No category code detected, using fallback: ${productCategoryCode}`);
            }
            
            // افزودن اطلاعات گروه به محصول
            const productWithGroup = {
                ...product,
                categoryCode: productCategoryCode,
                mainGroup: getCategoryGroup(productCategoryCode)
            };
            
            allProducts.push(productWithGroup);
        });
    }
    
    // مرتب‌سازی محصولات بر اساس نام
    allProducts.sort((a, b) => {
        const nameA = a.name.toLowerCase();
        const nameB = b.name.toLowerCase();
        if (nameA < nameB) return -1;
        if (nameA > nameB) return 1;
        return 0;
    });
    
    // افزودن همه محصولات به لیست بدون گروه‌بندی
    allProducts.forEach(product => {
        const option = document.createElement('option');
        option.value = product.id;
        
        // حذف شماره گروه از نام محصول (فقط اعداد و خط تیره یا نقطه‌ی ابتدای نام)
        const cleanProductName = product.name.replace(/^\d+\s*[-.:]\s*/, '').trim();
        option.textContent = cleanProductName;
        
        // ذخیره اطلاعات گروه در data attributes
        option.setAttribute('data-group', product.mainGroup);
        option.setAttribute('data-code', product.categoryCode);
        
        // ذخیره اطلاعات مالیات در ویژگی‌های data
        option.setAttribute('data-tax-enabled', product.tax_enabled ? '1' : '0');
        option.setAttribute('data-tax-rate', product.tax_rate || '0');
        option.setAttribute('data-vat-enabled', product.vat_enabled ? '1' : '0');
        option.setAttribute('data-vat-rate', product.vat_rate || '0');
        
        // اگر این محصول قبلاً انتخاب شده بود
        if (selectedId !== null && product.id == selectedId) {
            option.selected = true;
        }
        
        selectElement.appendChild(option);
    });
    
    return selectElement.value;
}

  function getFieldsHtmlByGroup(categoryCode, currentIndex) {
    console.log('Getting fields for category:', categoryCode, 'index:', currentIndex);
    let html = '';
    const fieldsToFilter = window.allFieldsData?.fields || [];
    
    // تبدیل categoryCode به حروف کوچک و حذف فضای خالی
    const cleanCategoryCode = categoryCode ? categoryCode.trim().toLowerCase() : '';
    
    // استخراج گروه اصلی از کد دسته‌بندی
    const mainGroup = getCategoryGroup(cleanCategoryCode);
    console.log('Main product group determined:', mainGroup);
    
    // اگر گروه مشخص نیست یا null است، پیام مناسب نمایش بده
    if (!mainGroup) {
        console.warn('Unable to determine product group for:', categoryCode);
        return `<div class="alert alert-warning">
                  گروه کالا مشخص نیست (کد: ${categoryCode || 'نامشخص'}).<br>
                  لطفا محصول دیگری را انتخاب کنید یا با مدیر سیستم تماس بگیرید.
                </div>`;
    }
    
    // دریافت همه گروه‌های محصول به صورت داینامیک
    const allGroups = getAllProductGroups();
    
    // بررسی اینکه آیا mainGroup در گروه‌های شناخته شده وجود دارد
    if (!allGroups.includes(mainGroup)) {
        console.warn(`Group ${mainGroup} is not in recognized groups list:`, allGroups);
        return `<div class="alert alert-warning">
                  گروه کالا "${mainGroup}" شناخته شده نیست.<br>
                  لطفا محصول دیگری را انتخاب کنید یا با مدیر سیستم تماس بگیرید.
                </div>`;
    }
    
    // فیلتر کردن فیلدها بر اساس گروه محصول
    // فقط فیلدهایی که گروه آنها دقیقاً با mainGroup مطابقت دارد و section آنها item_row است
    let groupFields = fieldsToFilter.filter(f => 
        f.section === 'item_row' && 
        f.group && 
        f.group.toString().trim().toLowerCase() === mainGroup.trim().toLowerCase()
    );
    
    // گزارش دقیق تعداد فیلدها در هر گروه
    console.log(`Total fields: ${fieldsToFilter.length}, Fields for group ${mainGroup}: ${groupFields.length}`);
    
    // بررسی نام فیلدها برای اطمینان از اینکه گروه‌بندی درست است
    groupFields.forEach(field => {
        console.log(`Field for ${mainGroup}: ${field.name} (ID: ${field.id})`);
    });
    
    if (groupFields.length === 0) {
        console.warn(`No fields found for group ${mainGroup}`);
        return `<div class="alert alert-warning">
                  فیلدی برای گروه کالای "${mainGroup}" تعریف نشده است.<br>
                  لطفا با مدیر سیستم تماس بگیرید.
                </div>`;
    }
    
    console.log(`Found ${groupFields.length} fields for group ${mainGroup}`);
    
    // فیلتر کردن دوباره فیلدها - فقط نگه داشتن فیلدهایی که مربوط به این گروه هستند
    groupFields = groupFields.filter(field => {
        if (!field.name) return false;
        
        const fieldName = field.name.toString().trim();
        
        // اگر فیلد مربوط به گروه حاضر است (containsPrefixOrSuffix)
        if (fieldName.includes(`_${mainGroup}`)) {
            return true;
        }
        
        // اگر فیلد مربوط به گروه دیگری است (چک کردن هر گروه به جز گروه فعلی)
        for (const otherGroup of allGroups) {
            if (otherGroup !== mainGroup && fieldName.includes(`_${otherGroup}`)) {
                return false;
            }
        }
        
        // فیلدهای عمومی بدون suffix گروه
        return true;
    });
    
    console.log(`After filtering, ${groupFields.length} fields remain for group ${mainGroup}`);
    
    // مرتب‌سازی فیلدها برای نمایش منظم
    const rows = {};
    groupFields.forEach(field => {
      const rowKey = field.row_display || 'row1';
      if (!rows[rowKey]) rows[rowKey] = [];
      rows[rowKey].push(field);
    });
  
    // دریافت وضعیت مالیات و ارزش افزوده محصول انتخاب‌شده
    let taxEnabled = false, vatEnabled = false;
    const productSelect = document.querySelector(`select[name="items[${currentIndex}][product_id]"]`);
    let selectedProduct = null;
    if (productSelect && window.productsData) {
      const productId = parseInt(productSelect.value);
      selectedProduct = window.productsData.find(p => parseInt(p.id) === productId);
      taxEnabled = selectedProduct && selectedProduct.tax_enabled ? true : false;
      vatEnabled = selectedProduct && selectedProduct.vat_enabled ? true : false;
    }
  
    // رندر کردن ردیف‌های فیلدها
    Object.keys(rows).sort().forEach(rowKey => {
      const fields = rows[rowKey];
      html += '<div class="row">';
      fields.forEach(field => {
        // فقط اگر فیلد مالیات یا ارزش افزوده است، وضعیت فعال بودن را چک کن
        if (field.name.startsWith('item_general_tax_') && !taxEnabled) return;
        if (field.name.startsWith('item_vat_') && !vatEnabled) return;
            
        let colClass = field.col_class || 'col-md-2';
        html += `<div class="${colClass}">${renderField(field, currentIndex)}</div>`;
      });
      html += '</div>';
    });
    
    return html;
}

  function getFieldConfigByName(fieldName) {
    return (window.allFieldsData?.fields || []).find(f => f.name === fieldName) || {};
  }

  function renderField(field, currentIndex) {
    const fieldName = `items[${currentIndex}][${field.name}]`;
    const placeholder = field.placeholder || '';
    const readonly = field.readonly ? 'readonly' : '';
    const required = field.required ? 'required' : '';
    let fieldHtml = '';
    fieldHtml += `<label class="form-label small">${field.label}</label>`;
    let extraAttrs = '';
    if (field.is_numeric) {
      if (field.name.includes('carat')) {
        extraAttrs = 'step="0.1" min="700" max="999.9" pattern="^(7\\d{2}(\\.\\d{1,1})?|8\\d{2}(\\.\\d{1,1})?|9[0-8]\\d(\\.\\d{1,1})?|999(\\.9)?)$"';
      } else if (field.name.includes('weight')) {
        extraAttrs = 'step="0.001" min="0" pattern="^\\d+(\\.\\d{1,3})?$"';
      } else {
        extraAttrs = 'step="1" min="0" pattern="^\\d+$"';
      }
    }
    let inputClass = 'form-control form-control-sm';
    if (field.is_numeric) inputClass += ' autonumeric';
    
    // تشخیص اینکه آیا فیلد مربوط به مرکز ری‌گیری است یا خیر
    const isAssayOfficeField = field.name === 'item_assay_office_melted';
    
    switch (field.type) {
      case 'text':
      case 'number':
        fieldHtml += `<input type="${field.type}" name="${fieldName}" class="${inputClass}" placeholder="${placeholder}" ${readonly} ${required} ${extraAttrs}>`;
        break;
      case 'select':
        fieldHtml += `<select name="${fieldName}" class="form-select form-select-sm ${isAssayOfficeField ? 'assay-office-select' : ''}" ${readonly} ${required}>`;
        fieldHtml += `<option value="">انتخاب...</option>`;
        (field.options || []).forEach(opt => {
          fieldHtml += `<option value="${opt.value}">${opt.label}</option>`;
        });
        fieldHtml += `</select>`;
        break;
      case 'textarea':
        fieldHtml += `<textarea name="${fieldName}" class="form-control form-control-sm" placeholder="${placeholder}" ${readonly} ${required}></textarea>`;
        break;
      default:
        fieldHtml += '';
    }
    return fieldHtml;
  }

  function bindRowEvents(rowElement, currentIndex) {
    const productSelect = rowElement.querySelector('.product-select');
    if (productSelect) {
        fillProductSelect(productSelect);
        productSelect.addEventListener('change', function () {
          const selectedOption = this.options[this.selectedIndex];
          const categoryCode = selectedOption ? selectedOption.dataset.code : null;
          const dynamicFieldsContainer = rowElement.querySelector(`#dynamic-fields-${currentIndex}`);
          
          if (dynamicFieldsContainer) {
              if (categoryCode) {
                  dynamicFieldsContainer.innerHTML = getFieldsHtmlByGroup(categoryCode, currentIndex);
                  initializeAllAutonumerics(dynamicFieldsContainer);
                  bindCalculationEvents(dynamicFieldsContainer, categoryCode, currentIndex);
                              
                    // فراخوانی loadAssayOffices بعد از ایجاد فیلدهای دینامیک
                    loadAssayOffices();
                    
                    // اجرای محاسبات اولیه با مظنه موجود
                    const mazanehInput = document.querySelector('[name="mazaneh_price"]');
                    if (mazanehInput && mazanehInput.value) {
                      const groupFormulas = allFormulas.filter(f => f.group === categoryCode);
                      calculateFormulasForRow(dynamicFieldsContainer, groupFormulas, currentIndex);
                   }
                }
            } else {
                console.error(`Dynamic fields container not found for row ${currentIndex}`);
            }
            updateSummaryFields();
        });
    } else {
        console.error(`Product select not found in row ${currentIndex}`);
    }
  }

  function validateRow(rowElement) {
    let isValid = true;
    rowElement.querySelectorAll('input[required], select[required]').forEach(input => {
      if (!input.value.trim()) {
        if (window.MESSAGES && MESSAGES.required_field) {
            showMessage('warning', MESSAGES.required_field + ` (${input.placeholder || input.name})`);
        } else {
            showMessage('warning', `فیلد ضروری (${input.placeholder || input.name}) خالی است.`);
        }
        input.focus();
        isValid = false;
        return false;
      }
      if (input.classList.contains('autonumeric')) {
        const numericValue = AutoNumeric.getNumber(input);
        if (isNaN(numericValue)) {
            if (window.MESSAGES && MESSAGES.invalid_number) {
                showMessage('warning', MESSAGES.invalid_number + ` (${input.placeholder || input.name})`);
            } else {
                showMessage('warning', `مقدار عددی نامعتبر (${input.placeholder || input.name}).`);
            }
            input.focus();
            isValid = false;
            return false;
        }
      }
    });
    return isValid;
  }

  function initializeAutonumeric(element) {
    if (!element || typeof AutoNumeric === 'undefined' || !element.name) return;
    
    try {
        // اول چک کنیم که آیا قبلاً AutoNumeric روی این المان اعمال شده یا نه
        const existingAnElement = AutoNumeric.getAutoNumericElement(element);
        if (existingAnElement) {
            try {
                existingAnElement.remove();
            } catch (e) {
                console.warn("Error removing existing AutoNumeric instance:", e);
            }
        }
        
        // استخراج نام فیلد برای تشخیص نوع آن
        const nameMatch = element.name && element.name.match(/items\[\d+\]\[(.+)\]/);
        const fieldName = nameMatch ? nameMatch[1] : null;
        const fieldConfig = getFieldConfigByName(fieldName);
        
        // ذخیره مقدار اولیه قبل از اعمال AutoNumeric
        let initialValue = '';
        
        // ابتدا از dataset.initialValue استفاده کنیم (اگر موجود باشد)
        if (element.dataset && element.dataset.initialValue) {
            initialValue = element.dataset.initialValue.toString().replace(/[٬,]/g, '');
            console.log(`Using dataset initialValue for ${element.name}: ${initialValue}`);
        }
        // اگر نبود، از value استفاده کنیم
        else if (element.value !== undefined && element.value !== null && element.value !== '') {
            initialValue = element.value.toString().replace(/[٬,]/g, '');
            console.log(`Using element value for ${element.name}: ${initialValue}`);
        }
        
        // تنظیمات پایه برای همه فیلدها
        let options = {
            decimalCharacter: '.',
            digitGroupSeparator: '٬',
            modifyValueOnWheel: false,
            allowDecimalPadding: true,
            emptyInputBehavior: 'zero', // تغییر به zero از null برای جلوگیری از خطاها
            watchExternalChanges: true, // به‌روزرسانی خودکار وقتی مقدار خارجی تغییر می‌کند
            unformatOnSubmit: true      // حذف فرمت‌بندی هنگام ارسال فرم
        };
        
        // تنظیمات خاص برای انواع مختلف فیلدها
        if (fieldConfig && fieldConfig.is_numeric) {
            if (fieldName && (fieldName.includes('unit_price') || fieldName.includes('total_price'))) {
                // قیمت‌ها - بدون اعشار
                options = {
                    ...options,
                    decimalPlaces: 0,
                    minimumValue: '0'
                };
            } else if (fieldName && fieldName.includes('carat')) {
                // عیار - حداکثر 3 رقم اعشار
                options = {
                    ...options,
                    decimalPlaces: 3,
                    minimumValue: '0'
                };
            } else if (fieldName && fieldName.includes('weight')) {
                // وزن - حداکثر 3 رقم اعشار
                options = {
                    ...options,
                    decimalPlaces: 3,
                    minimumValue: '0'
                };
            } else if (fieldName && (fieldName.includes('fee_percent') || fieldName.includes('profit_percent'))) {
                // درصدها - حداکثر 2 رقم اعشار بین 0 تا 100
                options = {
                    ...options,
                    decimalPlaces: 2,
                    minimumValue: '0',
                    maximumValue: '100'
                };
            } else {
                // سایر فیلدهای عددی - بدون اعشار
                options = {
                    ...options,
                    decimalPlaces: 0,
                    minimumValue: '0'
                };
            }
        }
        
        try {
            // حذف نمونه‌های قبلی
            if (element.autoNumeric) {
                element.autoNumeric.remove();
            }
            
            // اگر AutoNumeric قبلاً روی این المان اعمال شده، آن را حذف کنیم
            try {
                const anInstance = AutoNumeric.getAutoNumericElement(element);
                if (anInstance) {
                    anInstance.remove();
                }
            } catch (e) {
                console.warn(`Error removing existing AutoNumeric for ${element.name}:`, e);
            }
            
            // مقدار اولیه را به صورت عدد خام تبدیل کنیم
            let rawValue = null;
            if (initialValue !== '') {
                try {
                    // حذف هرگونه کاراکتر غیر عددی به جز نقطه اعشار
                    const cleanValue = initialValue.toString().replace(/[^\d.-]/g, '');
                    rawValue = parseFloat(cleanValue);
                    console.log(`Parsed numeric value for ${element.name}: ${rawValue}`);
                } catch (e) {
                    console.warn(`Error parsing value for ${element.name}:`, e);
                }
            }
            
            // ابتدا مقدار عددی خام را در المان قرار دهیم
            if (rawValue !== null && !isNaN(rawValue)) {
                element.value = rawValue.toString();
            }
            
            // ایجاد نمونه جدید AutoNumeric
            new AutoNumeric(element, options);
            
            // مقداردهی با استفاده از متد set
            if (rawValue !== null && !isNaN(rawValue)) {
                setTimeout(() => {
                    try {
                        console.log(`Setting final AutoNumeric value for ${element.name} to ${rawValue}`);
                        AutoNumeric.set(element, rawValue);
                    } catch (e) {
                        console.error(`Error setting AutoNumeric value for ${element.name}:`, e);
                    }
                }, 0);
            }
        } catch (e) {
            console.error("Error initializing AutoNumeric for element:", element, "options:", options, "Error:", e);
        }
        
        // اضافه کردن اعتبارسنجی عیار و وزن فقط در جاوااسکریپت
        if (fieldName && fieldName.includes('carat')) {
            // فقط اگر گروه جواهر نیست
            if (!(fieldConfig && fieldConfig.group === 'جواهر') && !fieldName.includes('jewelry')) {
                element.addEventListener('blur', function() {
                    let val = this.value.replace(/٬|,/g, '').trim();
                    if (val === '') return;
                    
                    let num = parseFloat(val);
                    // بررسی معتبر بودن عیار
                    if ((Number.isInteger(num) && num >= 700 && num <= 999) || (num === 999.9)) {
                        if (Number.isInteger(num)) {
                            AutoNumeric.set(this, num);
                        } else if (num === 999.9) {
                            AutoNumeric.set(this, 999.9);
                        }
                    } else {
                        // مقدار عیار نامعتبر
                        this.value = '';
                        AutoNumeric.set(this, 0);
                        showMessage('error', 'عیار فقط باید عدد صحیح بین ۷۰۰ تا ۹۹۹ یا ۹۹۹.۹ باشد.');
                    }
                });
            }
        }
        
        // اعتبارسنجی وزن
        if (fieldName && fieldName.includes('weight')) {
            // اگر وزن جواهر است (قیراط)
            if (fieldName === 'item_weight_carat_jewelry') {
                element.addEventListener('blur', function() {
                    const val = parseFloat(this.value.replace(/٬|,/g, ''));
                    if (isNaN(val) || val <= 0) {
                        this.value = '';
                        AutoNumeric.set(this, 0);
                        showMessage('error', 'وزن قیراط باید عدد مثبت و معتبر باشد.');
                    }
                });
            } else {
                // سایر وزن‌ها
                element.addEventListener('blur', function() {
                    const val = parseFloat(this.value.replace(/٬|,/g, ''));
                    if (isNaN(val) || val < 0) {
                        this.value = '';
                        AutoNumeric.set(this, 0);
                        showMessage('error', 'وزن باید عدد مثبت و معتبر باشد.');
                    }
                });
            }
        }
    } catch (e) {
        console.error("Global error in initializeAutonumeric:", e);
    }
}

function initializeAllAutonumerics(context = document) {
    context.querySelectorAll('.autonumeric').forEach(el => initializeAutonumeric(el));
}

// دریافت لیست مراکز ری‌گیری
function loadAssayOffices() {
    console.log('Fetching assay offices from:', baseUrl + '/app/assay-offices/list'); // اضافه کردن لاگ
    fetch(baseUrl + '/app/assay-offices/list')
        .then(response => {
            console.log('Response status:', response.status); // اضافه کردن لاگ
            if (!response.ok) {
                throw new Error('Network response was not ok: ' + response.status);
            }
            return response.json();
        })
        .then(response => {
            console.log('Response data:', response); // اضافه کردن لاگ
            if (response.success && response.data) {
                const offices = response.data;
                fillAssayOfficeSelect(offices);
            } else {
                console.error('Invalid response format:', response); // اضافه کردن لاگ
                showMessage('error', 'خطا در ساختار پاسخ دریافتی از سرور');
            }
        })
        .catch(error => {
            console.error('Error loading assay offices:', error);
            showMessage('error', 'خطا در دریافت لیست مراکز ری‌گیری');
        });
}

// تابع پر کردن تمام لیست‌های مراکز ری‌گیری
function fillAssayOfficeSelect(offices) {
    if (!Array.isArray(offices) || offices.length === 0) {
      console.warn('No assay offices found or invalid data format');
      return;
    }
    
    // پر کردن تمام select های مربوط به مراکز ری‌گیری
    document.querySelectorAll('select[name$="[item_assay_office_melted]"]').forEach(select => {
      console.log('Filling assay office select:', select);
      // حفظ گزینه انتخاب شده فعلی اگر وجود داشته باشد
      const currentValue = select.value;
      console.log('Current assay office value:', currentValue);
      
      // نگه داشتن option فعلی
      if (currentValue) {
        select.innerHTML = '<option value="">انتخاب کنید...</option>';
      } else {
        select.innerHTML = '<option value="" selected>انتخاب کنید...</option>';
      }
      
      offices.forEach(office => {
        const option = document.createElement('option');
        option.value = office.id;
        option.textContent = office.name;
        if (currentValue && currentValue == office.id) {
          option.selected = true;
          console.log('Selecting assay office:', office.name, office.id);
        }
        select.appendChild(option);
      });
    });
  }

  // فراخوانی تابع loadAssayOffices در زمان آماده شدن صفحه
  document.addEventListener('DOMContentLoaded', function() {
    // رویداد تغییر مظنه
    const mazanehInput = document.querySelector('[name="mazaneh_price"]');
    if (mazanehInput) {
        console.log('mazaneh input event bound');
        mazanehInput.addEventListener('input', function() {
            console.log('mazaneh value changed to:', this.value);
            document.querySelectorAll('.transaction-item-row').forEach((row, idx) => {
                // اجرای مجدد محاسبات ردیف
                const categoryCode = row.querySelector('.product-select')?.selectedOptions[0]?.dataset.code;
                const dynamicFieldsContainer = row.querySelector(`#dynamic-fields-${idx}`);
                if (dynamicFieldsContainer && categoryCode) {
                    console.log('Recalculating row', idx, 'with group', categoryCode);
                    const groupFormulas = allFormulas.filter(f => f.group === categoryCode);
                    calculateFormulasForRow(dynamicFieldsContainer, groupFormulas, idx);
                }
            });
        });
    } else {
        console.warn('mazaneh input element not found for binding event!');
    }

    if (itemsContainer.children.length === 0) {
        addNewEmptyItemRow();
    }
  });

  // اضافه کردن فراخوانی loadAssayOffices در تابع addNewRow
  function addNewRow(group) {
    loadAssayOffices(); // پر کردن select های جدید
  }

  function updateItemFields(row, product) {
    if (!product || !product.category) {
        console.warn('Product or category information is missing', product);
        return;
    }
    
    // استخراج کد دسته‌بندی محصول
    let categoryCode = '';
    
    if (typeof product.category === 'object') {
        categoryCode = product.category.code || product.category.base_category || '';
    } else if (typeof product.category === 'string') {
        categoryCode = product.category;
    }
    
    // اگر هنوز کد دسته‌بندی مشخص نشده، از category_id استفاده کنیم
    if (!categoryCode && product.category_id) {
        if (window.categoryIdToBaseCategory && window.categoryIdToBaseCategory[product.category_id]) {
            categoryCode = window.categoryIdToBaseCategory[product.category_id];
        } else {
            categoryCode = product.group || '';
        }
    }
    
    // تعیین گروه اصلی محصول
    const mainGroup = getCategoryGroup(categoryCode);
    console.log('Updating fields for product:', product.name, 'Category:', categoryCode, 'Group:', mainGroup);
    
    // اگر گروه محصول مشخص نیست یا معتبر نیست، نمایش پیام خطا
    if (!mainGroup || (mainGroup !== 'melted' && mainGroup !== 'manufactured' && mainGroup !== 'coin' && 
                       mainGroup !== 'goldbullion' && mainGroup !== 'silverbullion' && mainGroup !== 'jewelry')) {
        console.warn(`Invalid product group ${mainGroup} for product ${product.name} (ID: ${product.id})`);
        
        // نمایش پیام خطا در فرم
        const dynamicFieldsContainer = row.querySelector('.dynamic-fields-row');
        if (dynamicFieldsContainer) {
            dynamicFieldsContainer.innerHTML = `<div class="col-12">
                <div class="alert alert-warning">
                  گروه کالا مشخص نیست یا معتبر نیست (کد: ${categoryCode || 'نامشخص'}).<br>
                  لطفا محصول دیگری را انتخاب کنید یا با مدیر سیستم تماس بگیرید.
                </div>
            </div>`;
        }
        return;
    }
    
    // دریافت همه گروه‌های محصول به صورت داینامیک
    const allGroups = getAllProductGroups();
    
    const unitOfMeasure = product.unit_of_measure || 'gram';
    
    // پنهان کردن همه فیلدها
    row.querySelectorAll('.item-field').forEach(field => field.style.display = 'none');
    
    // عملکرد داینامیک - جستجوی فیلدها بر اساس نام فیلد و گروه محصول
    if (window.allFieldsData?.fields) {
        // فیلتر کردن فیلدها بر اساس section و group
        const relevantFields = window.allFieldsData.fields.filter(f => 
            f.section === 'item_row' && 
            f.group && 
            f.group.toString().trim().toLowerCase() === mainGroup.trim().toLowerCase()
        );
        
        console.log(`Found ${relevantFields.length} fields for item row in group ${mainGroup}`);
        
        // فیلتر کردن دوباره فیلدها - حذف فیلدهای گروه‌های دیگر
        const filteredFields = relevantFields.filter(field => {
            if (!field.name) return false;
            const fieldName = field.name.toString().trim();
            
            // اگر فیلد مربوط به گروه حاضر است (containsPrefixOrSuffix)
            if (fieldName.includes(`_${mainGroup}`)) {
                return true;
            }
            
            // اگر فیلد مربوط به گروه دیگری است (چک کردن هر گروه به جز گروه فعلی)
            for (const otherGroup of allGroups) {
                if (otherGroup !== mainGroup && fieldName.includes(`_${otherGroup}`)) {
                    return false;
                }
            }
            
            // فیلدهای عمومی
            return true;
        });
        
        console.log(`After filtering, ${filteredFields.length} fields remain for display`);
        
        // فیلتر کردن و گروه‌بندی فیلدها بر اساس نوع
        const fieldGroups = {
            weight: filteredFields.filter(f => f.name.includes('weight')),
            carat: filteredFields.filter(f => f.name.includes('carat')),
            price: filteredFields.filter(f => f.name.includes('price') || f.name.includes('amount')),
            quantity: filteredFields.filter(f => f.name.includes('quantity')),
            fee: filteredFields.filter(f => f.name.includes('fee')),
            profit: filteredFields.filter(f => f.name.includes('profit')),
            manufacturing: filteredFields.filter(f => f.name.includes('manufacturing')),
            assay: filteredFields.filter(f => f.name.includes('assay')),
            appurtenances: filteredFields.filter(f => f.name.includes('appurtenances')),
            workshop: filteredFields.filter(f => f.name.includes('workshop')),
            other: []
        };
        
        // فیلدهایی که در هیچ کدام از گروه‌های بالا نیستند
        fieldGroups.other = filteredFields.filter(f => 
            !Object.keys(fieldGroups).some(key => 
                key !== 'other' && fieldGroups[key].includes(f)
            )
        );
        
        // نمایش فیلدها بر اساس نوع محصول
        for (const groupName in fieldGroups) {
            const fieldsInGroup = fieldGroups[groupName];
            
            fieldsInGroup.forEach(field => {
                if (!field.class) return;
                
                const fieldElement = row.querySelector(`.${field.class}`);
                if (fieldElement) {
                    fieldElement.parentElement.style.display = '';
                    console.log(`Showing field: ${field.name}`);
                }
            });
        }
    } else {
        console.warn('Field definitions not available (window.allFieldsData?.fields)');
    }
}

function getCategoryGroup(categoryCode) {
    console.log('Getting category group for code:', categoryCode);
    
    // اگر ورودی خالی باشد، از خود ورودی استفاده کن یا null برگردان
    if (!categoryCode) {
        console.warn('Empty category code - returning null');
        return null;
    }
    
    // تبدیل به رشته و حذف فضای خالی
    const normalizedCode = categoryCode.toString().trim().toLowerCase();
    
    // دریافت همه گروه‌های محصول
    const allGroups = getAllProductGroups();
    
    // 1. بررسی تطابق دقیق: اگر کد دسته‌بندی دقیقاً یکی از گروه‌های موجود است
    if (allGroups.includes(normalizedCode)) {
        console.log(`Exact match found for category code: ${normalizedCode}`);
        return normalizedCode;
    }
    
    // 2. نگاشت کدهای عددی به گروه‌های محصول
    const categoryCodeMap = {
        // کدهای اصلی دسته‌بندی‌ها (باید با window.categoryIdToBaseCategory مطابقت داشته باشد)
        '20': 'melted',       // طلای آب‌شده
        '21': 'coin',         // سکه طلا
        '22': 'manufactured', // طلای ساخته شده
        '23': 'goldbullion',  // شمش طلا
        '27': 'jewelry',      // جواهرات
        '28': 'silverbullion', // شمش نقره
        
        // کدهای قدیمی دسته‌بندی (برای سازگاری با داده‌های قبلی)
        '1': 'melted',
        '2': 'manufactured',
        '3': 'coin',
        '4': 'jewelry',
        '5': 'goldbullion',
        '6': 'silverbullion'
    };
       
    if (categoryCodeMap[normalizedCode]) {
        console.log(`Mapped numeric code ${normalizedCode} to group: ${categoryCodeMap[normalizedCode]}`);
        return categoryCodeMap[normalizedCode];
    }
    
    // 3. بررسی تطابق بر اساس کلمات کلیدی
    const groupKeywords = {
        'melted': ['gold', 'melt', 'آبشده', 'abshode', 'gold_melted'],
        'manufactured': ['manuf', 'ساخته شده', 'sakhteshode', 'gold_manufactured', 'دستبند', 'النگو', 'گردنبند', 'زنجیر'],
        'coin': ['coin', 'سکه', 'sekke', 'gold_coin'],
        'goldbullion': ['goldbullion', 'شمش طلا', 'gold_bullion', 'bullion_gold', 'shemsh_tala', 'شمش'],
        'silverbullion': ['silverbullion', 'شمش نقره', 'silver_bullion', 'bullion_silver', 'shemsh_noghre'],
        'jewelry': ['jewelry', 'جواهر', 'gold_jewelry', 'javaher']
    };
    
    for (const [group, keywords] of Object.entries(groupKeywords)) {
        for (const keyword of keywords) {
            if (normalizedCode.includes(keyword)) {
                console.log(`Match found for category ${normalizedCode} via keyword: ${keyword}`);
                return group;
            }
        }
    }
    
    // 4. بررسی تطابق جزئی با گروه‌های موجود
    for (const group of allGroups) {
        if (normalizedCode.includes(group) || group.includes(normalizedCode)) {
            console.log(`Partial match found for category ${normalizedCode} with group: ${group}`);
            return group;
        }
    }
    
    // 5. برگرداندن خود کد به عنوان گروه اگر هیچ تطابقی پیدا نشد
    // این باعث می‌شود که فیلدهای محصول نمایش داده نشوند اما بهتر از این است که به اشتباه manufactured نمایش داده شود
    console.warn(`No matching group found for category code: ${categoryCode}, returning original code instead of defaulting to manufactured`);
    return normalizedCode;
}

function updateSummaryFields() {
  // لیست summary formulaها را از allFormulas پیدا کن (فرمول‌هایی که group ندارند و output_field ندارند یا فقط name دارند)
  const summaryFormulas = (window.allFormulasData?.formulas || []).filter(f => !f.group && f.form === 'transactions/form.php');
  // جمع مقادیر مورد نیاز هر summary را از روی inputها جمع بزن
  const summaryValues = {};
  // ابتدا همه فیلدهای مورد نیاز را جمع بزن
  summaryFormulas.forEach(formula => {
    const values = {};
    (formula.fields || []).forEach(field => {
      // اگر فیلد خودش یک summary است، از summaryValues بگیر
      if (summaryValues[field] !== undefined) {
        values[field] = summaryValues[field];
      } else {
        // جمع همه inputهای مربوط به این فیلد در ردیف‌ها
        let sum = 0;
        document.querySelectorAll(`input[name^="items"][name$="[${field}]"]`).forEach(input => {
          let value = 0;
          if (input.classList.contains('autonumeric') && typeof AutoNumeric !== 'undefined') {
            value = AutoNumeric.getNumber(input);
          } else {
            value = parseFloat(input.value.replace(/٬|,/g, '')) || 0;
          }
          sum += value;
        });
        values[field] = sum;
      }
    });
    // جایگزینی متغیرها در فرمول
    let formulaStr = formula.formula;
    for (const key in values) {
      const regex = new RegExp(key, 'g');
      formulaStr = formulaStr.replace(regex, values[key]);
    }
    let result = 0;
    try {
      result = eval(formulaStr);
    } catch (e) {
      console.error('Error evaluating summary formula', formula.name, formulaStr, e);
    }
    summaryValues[formula.name] = result;
    // مقداردهی به summaryها در DOM
    const el = document.getElementById('summary-' + formula.name);
    if (el) el.textContent = result ? Math.round(result).toLocaleString('fa-IR') : '۰';
  });
}
});